<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title> Brick Break CISC474</title>
    <h1 align="center">Brick Break CISC474</h1>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <style>
            * {
                padding: 0;
                margin: 200;
            }

            canvas {
                display: block;
                margin: 0 auto;
            }
        </style>
</head>

<body>
    <canvas id="myCanvas" width="520" height="400" style="background: url('background.jpg')"></canvas>
    <img id="ball" src="ball.png">
    <img id="paddle" src="paddle.png">

    <script>
        
        var canvas = $('#myCanvas')[0];
        var ctx = $('#myCanvas')[0].getContext("2d");

        // Ball init position
        var xBall = canvas.width / 2;
        var yBall = canvas.height - 30;
        // Ball movement variables
        var xMove = 2;
        var yMove = -2;
        var ballRadius = 10;

        // Paddle
        var paddleHeight = 10;
        var paddleWidth = 75;
        var paddleX = (canvas.width - paddleWidth) / 2;
        var paddleOffset = 5;

        // Bricks
        var brickRows = 3;
        var brickCols = 5;
        var brickWidth = 75;
        var brickHeight = 20;
        var brickPadding = 10;
        var brickOffset = 50;

        var bricks = [];
        for (i = 0; i < brickCols; i++) {
            bricks[i] = [];
            for (j = 0; j < brickRows; j++) {
                bricks[i][j] = { x: 0, y: 0, broken: 0 }; // Broken flag if it has been broken or not
            }
        }

        // User input initialization
        var leftPressed = false;
        var rightPressed = false;
        // Left and right arrows to control paddle
        $(document).ready().keyup(keyUpHandler);
        $(document).ready().keydown(keyDownHandler);

        function drawBall() {
            ctx.beginPath();
            ctx.arc(xBall, yBall, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#FF0000";
            ctx.fill();
            ctx.closePath();
                // window.onload = function() {
                //     var img = document.getElementById("ball");
                //     ctx.drawImage(img, xBall, yBall);
                //     console.log(xBall, yBall);
                // }
            }
        

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight - paddleOffset, paddleWidth, paddleHeight);
            ctx.fillStyle = "green";
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (i = 0; i < brickCols; i++) {
                for (j = 0; j < brickRows; j++) {
                    if (bricks[i][j].broken == 0) {
                        var brickX = (i * (brickWidth + brickPadding)) + brickOffset;
                        var brickY = (j * (brickHeight + brickPadding)) + brickOffset;
                        bricks[i][j].x = brickX;
                        bricks[i][j].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = "#2040E1";
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBricks();
            drawPaddle();
            drawBall();
            brickCollision();

            // Keep ball in boundaries of screen
            if (yBall + yMove < ballRadius) { // Top of screen
                yMove = -yMove;
            }
            else if (yBall + yMove > canvas.height - (paddleHeight + ballRadius + paddleOffset)) { // Ball height of top of paddle
                if (xBall > paddleX && xBall < paddleX + paddleWidth) { // Ball within paddle x bounds
                    yMove = -yMove;
                }
                else if (xBall < paddleX || xBall > paddleX + paddleWidth) { // Ball outside of paddle x bounds, keeps moving until bottom of screen
                    yMove = yMove;
                    if (yBall + yMove > canvas.height) {
                        alert("Game Over");
                        document.location.reload();
                    }

                }

            }
            if (xBall + xMove < ballRadius || xBall + xMove > canvas.width - ballRadius) { // Left and right of screen
                xMove = -xMove
            }
            // Moves ball
            xBall += xMove;
            yBall += yMove;


            // Move Paddle
            if (rightPressed && paddleX < canvas.width - paddleWidth) {
                paddleX += 7;
            }
            if (leftPressed && paddleX > 0) {
                paddleX -= 7;
            }
            requestAnimationFrame(draw);

        }

        // Handling user input
        function keyDownHandler(e) {
            if (e.keyCode == 39) {
                rightPressed = true;
            }
            else if (e.keyCode == 37) {
                leftPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.keyCode == 39) {
                rightPressed = false;
            }
            else if (e.keyCode == 37) {
                leftPressed = false;
            }
        }

        function brickCollision() {
            for (i = 0; i < brickCols; i++) {
                for (j = 0; j < brickRows; j++) {
                    var brick = bricks[i][j];
                    if (brick.broken == 0) {
                        if (xBall > brick.x && xBall < brick.x + brickWidth && yBall > brick.y && yBall < brick.y + brickHeight) {
                            yMove = -yMove;
                            brick.broken = 1;
                        }
                    }
                }
            }
        }
        draw();
    </script>

</body>

</html>